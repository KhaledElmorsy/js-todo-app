{"version":3,"file":"main.js","mappings":"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","sources":["webpack://js-todolist/./src/model.js","webpack://js-todolist/./src/templates/helpers.js","webpack://js-todolist/./src/templates/index.js","webpack://js-todolist/./src/templates/todo.js","webpack://js-todolist/./src/templates/project.js","webpack://js-todolist/./src/templates/checklist.js","webpack://js-todolist/./src/templates/projectList.js","webpack://js-todolist/./src/view.js","webpack://js-todolist/./src/controller.js","webpack://js-todolist/./src/index.js"],"sourcesContent":["/**\n * Models define how the app's data is stored. For this app, models are structured\n * as nested objects with each parent containing an array of child objects.\n *\n * The object heirarchy is: Project List (App) -> Projects -> Todos -> Checklist Items\n *\n * @namespace Models\n */\n\n/**\n * @typedef {DataModel} DataModel\n * @ignore\n */\n/**\n * Main parent class for basic data objects: Projects, Todos, and Checklist Items.\n * Each instance has an ID, status flag, and visible flag.\n *\n * @memberof Models\n */\nclass DataModel {\n  /**\n   * Create a model object\n   * @param {number} id ID to be assigned to the instance.\n   */\n  constructor(id) {\n    /**\n     * ID of the object. Used as index in parent object's array.\n     * @type {number}\n     */\n    this.id = id;\n    /**\n     * Indiciates if the object is 'done' or not. True = done.\n     *\n     * Default: false\n     * @type {Boolean}\n     */\n    this.status = false;\n    /**\n     * Indicates if the object should be rendered. True = render.\n     * <br><br>\n     *\n     * When a user removes an object, it's not deleted from the parent's array,\n     * instead its visibility is set to 'false'.\n     * <br><br>\n     *\n     * Default: true.\n     * @type {Boolean}\n     */\n    this.visible = true;\n  }\n}\n\n/**\n * Model for checklist items - subtasks for each Todo item\n *\n * @memberof Models\n * @extends DataModel\n * @extends Models.DataModel\n */\nclass ChecklistItem extends DataModel {\n  /**\n   * Create a new checklist item\n   * @param {number} id ID to be assigned to the checklist item\n   * @param {string} descr Descirption to added to the item.\n   */\n  constructor(id, descr) {\n    super(id);\n    /**\n     * Description of the task to be done\n     * @type {string}\n     */\n    this.descr = descr;\n  }\n}\n\n/**\n * Model for todo items\n *\n * @memberof Models\n * @extends DataModel\n * @extends Models.DataModel\n */\nclass Todo extends DataModel {\n  /**\n   * Create new Todo Item\n   * @param {number} id ID to assign - Also acts as index in parent's array object\n   * @param {string} title Main title of the Todo Item\n   * @param {string} descr Description of the todo with more details. Optional - Defualt = null\n   * @param {string} endDate End Date of the todo item. Optional - Default = null\n   * @param {string} startDate Start date of the todo item. Optional - Default = null\n   * @param {ChecklistItem[]} [list=[]]  Array of checklist items. Default = empty array.\n   */\n  constructor(id, title, descr = null, endDate = null, startDate = null, list = null) {\n    super(id);\n    /**\n     * Main title of the Todo Item\n     * @type {string}\n     */\n    this.title = title;\n\n    /**\n     * Description of the todo with more details\n     * @type {string}\n     */\n    this.descr = descr;\n\n    /**\n     * End Date of the todo item\n     * @type {string}\n     */\n    this.endDate = endDate;\n\n    /**\n     * Start date of the todo item\n     * @type {string}\n     */\n    this.startDate = startDate;\n\n    /**\n     * Array of checklist items\n     * @type {ChecklistItem[]}\n     */\n    this.list = list;\n  }\n}\n\n/**\n * Project Model that contains todo items\n *\n * @memberof Models\n * @extends DataModel\n * @extends Models.DataModel\n */\nclass Project extends DataModel {\n  /**\n   *\n   * @param {number} id ID to assign to project\n   * @param {string} title Name of the project\n   * @param {Todo[]} [list= []] Array of todo objects. Default: empty array.\n   */\n  constructor(id, title, list = []) {\n    super(id);\n    /**\n     * Project title/name\n     * @type {string}\n     */\n    this.title = title;\n    /**\n     * Array of todo objects\n     * @type {Todo[]}\n     */\n    this.list = list;\n  }\n}\n\n/**\n * Main app object containing a list of projects\n * @memberof Models\n */\nclass ProjectList {\n  /** Create project list by loading from local storage if available or creating an empty list */\n  constructor() {\n    const storedData = localStorage.projectList;\n    /**\n     * Array of project objects. Loaded from local storage.\n     *\n     * If local storage location is empty, defaults to empty array.\n     * @type {Project[]}\n     */\n    this.list = storedData ? JSON.parse(storedData) : [];\n  }\n}\n\nexport {\n  ChecklistItem,\n  Project,\n  Todo,\n  ProjectList,\n};\n","/**\n * Functions to facilitate Template literal interpolation with model objects\n * @namespace Views.TemplateHelpers\n */\n\n/**\n * Returns a string based on the model's status that can be added to a view element's class list\n * @memberof Views.TemplateHelpers\n * @param {Object} model - Model object being checked\n * @param {string} htmlClass - string to be returned if the model's status is 'true'\n * @returns {string} - HTML class name if Todo's status is true, blank ('') if false.\n */\nfunction statusToClass(model, htmlClass) {\n  return model.status ? htmlClass : '';\n}\n/** @typedef {import('../model.js').DataModel} DataModel */\n/**\n  * Filters child objects based on their visibility\n  * @memberof Views.TemplateHelpers\n  * @param {DataModel[]} list - Array of model objects\n  * @returns {DataModel[]} - Filtered array of model objects\n  */\nfunction getVisible(list) { return list.filter((item) => item.visible); }\n\nexport { statusToClass, getVisible };\n","/* eslint-disable max-len */\nimport todoTemplates from './todo';\nimport projectTemplates from './project';\nimport checklistTemplates from './checklist';\nimport projectListTemplates from './projectList';\n/** @typedef {import(\"../model.js\").DataModel} DataModel */\n\n/**\n * In this project, templates are functions that optionally receive model \n * objects and use them to interpolate template literals and return strings of HTML.\n * Template modules contain templates related to a specific view.\n * Open one and check them out (project.js is intense)\n */\n\n/**\n * Converts template literals into HTML element objects.\n * <br><br>\n *\n * Note: This isn't straightforward because you can't edit an element objects outer \n * HTML if it's not in the document, so a temporary wrapper element is used.\n *\n * @memberof Views.Templates\n *\n * @param {string} elementHTML - The outer HTML of the element being created\n * @returns {Element} - Element object\n */\nconst convertElement = (elementHTML) => {\n  const tempWrapper = document.createElement('div');\n  tempWrapper.innerHTML = elementHTML;\n\n  // Consistently keep the output as a single element object, NOT HTML Collections or nulls\n  if (tempWrapper.childElementCount !== 1) {\n    return tempWrapper; // Returning the wrapper is a failsafe, not a feature.\n  }\n\n  return tempWrapper.firstChild;\n};\n\n/**\n * Consilidate template modules into a dictionary to allow view constructors to reference them with the {@link templates command pattern} below.\n *\n * @namespace Views.Templates\n *\n * @property {Object} Todo - Todo View Templates {@link todoTemplates see here}\n * @property {Object} Project - Project View Templates {@link projectTemplates see here}\n * @property {Object} Checklist - Checklist View Templates {@link checklistTemplates see here}\n * @property {Object} ProjectList - Project List View Templates {@link projectListTemplates see here}\n */\nconst viewTemplates = {\n  Todo: todoTemplates,\n  Project: projectTemplates,\n  Checklist: checklistTemplates,\n  ProjectList: projectListTemplates,\n};\n\n/**\n * Takes the view and element types as inputs and returns a function that\n * accepts a model object and returns an HTML element.\n * <br><br>\n *\n * The returned function calls the appropriate template function by creating a\n * reference to members of nested objects, similar to a command pattern.\n * <br><br>\n *\n * {@link templates View}\n * @memberof Views.Templates\n * @default\n *\n * @param {string} view - View/Model type (Todo, Project, Project List)\n * @param {string} type - Template type (standard, add, edit)\n * @returns {Function} - Function that accepts a model and returns an Element object\n */\nexport default function templates(view, type) {\n  /**\n    * Creates and returns an HTML element using the template specificied when this function was created.\n    * Optionally using a model object.\n    * @param {DataModel} model - (Optional) Model object used to populate the element's HTML\n    * @returns {Element} - HTML element\n    */\n  return function (model = null) {\n    const templateHTML = viewTemplates[view][type](model);\n    return convertElement(templateHTML);\n  };\n}\n","import { statusToClass } from './helpers';\n\n/**\n * Template for the element that shows the Todo item in more detail.\n * Is rendered by the view when you click the todo item.\n *\n * {@link todoTemplates Visit Module}\n * @namespace TodoTemplates\n * @memberof Views.Templates\n *\n * @property {Function} standard - Create Outer HTML for the standard Todo View Element {@link todoTemplates.standard see here}\n */\nconst todoTemplates = {\n  /**\n   * Todo model object\n   * @typedef {import ('../model.js').Todo} Todo\n   */\n\n  /**\n   * Generate HTML for a modal element using a todo object model. The modal displays\n   * properties of the Todo item in more detail.\n   *\n   * {@link todoTemplates.standard View}\n   * @memberof Views.Templates.TodoTemplates\n   *\n   * @param {Todo} todoObj Todo object to fill modal values with\n   * @returns {string} Element Outer HTML\n   */\n  standard(todoObj) {\n    const elementHTML =\n        `<div id=\"todo-background\">\n            <form id=\"todo-details\" class=\"${statusToClass(todoObj,'done')}\">\n                <input required class=\"title\" name=\"title\" value=\"${todoObj.title}\">\n                <textarea class=\"descr\" name=\"descr\">${todoObj.descr}</textarea>\n                <div class=\"checklist-container\">\n                    <h3>Tasks</h3>\n                    <div id=\"checklist\"></div>\n                </div>\n                <div class=\"dates\">\n                    <div class=\"date-container\">\n                        <p class=\"date-type\">Start Date</p>\n                        <input type=\"date\" name=\"startDate\" value=\"${todoObj.startDate || ''}\">\n                    </div>\n                    <div class=\"date-container\">\n                        <p class=\"date-type\">End Date</p>\n                        <input type=\"date\" name=\"endDate\" value=\"${todoObj.endDate || ''}\">\n                    </div>\n                </div>\n                <div class=\"button-container\">\n                    <button class=\"save button\" type=\"submit\" name=\"save\">Save</button>\n                    <div class=\"done-toggle button\">Done</div>\n                    <div class=\"delete button\">Delete</div>\n                </div>\n            </form>\n        </div>`;\n    return elementHTML;\n  },\n};\n\nexport default todoTemplates;\n","import { statusToClass, getVisible } from './helpers';\n\n/**\n * This module consolidates the tempaltes that are used to render the project view.\n * <br><br>\n *\n * A project contains an array of todo objects. To render a project, a populator-type\n * view is used that iterates through the array and creates separate elements for \n * each todo object.\n * <br><br>\n *\n * There are other templates that can be rendered by the View for adding new Todos, editing Todos, and\n * informing the user that they need to add a new project if the project list's empty.\n *\n * {@link projectTemplates Visit Module}\n * @namespace ProjectTemplates\n * @memberof Views.Templates\n *\n * @property {Function} add - Create 'Add Todo Form' element HTML {@link projectTemplates.add see here}\n * @property {Function} standard - Create 'Standard Todo' element HTML {@link projectTemplates.standard see here}\n * @property {Function} edit  - Create 'Edit Todo' element HTML {@link projectTemplates.edit see here}\n * @property {Function} empty - Create 'Empty Projects' element HTML {@link projectTemplates.empty see here}\n *\n */\nconst projectTemplates = {\n\n  /** Todo model object\n   *  @typedef { import(\"../model.js\").Todo} Todo\n   */\n\n  /**\n   * Create an HTML string of the standard element displaying a Todo's information \n   * in the Project View.\n   *\n   * {@link projectTemplates.standard View}\n   * @memberof Views.Templates.ProjectTemplates\n   * @param {Todo} todoObj Todo model object\n   * @returns {string} Element's Outer HTML\n   */\n  standard(todoObj) {\n    const elementHTML =\n        `<div class=\"card ${statusToClass(todoObj, 'done')}\" data-child-id=\"${todoObj.id}\">\n            <h2 class=\"title\">${todoObj.title}</h2>\n            <p class=\"descr\">${todoObj.descr}</p>\n            <h4 class=\"checklist-title\">Tasks</h4>\n            <div class=\"checklist-container\">${\n            ( // Item Array > Filter inactive > Map to template string > Slice First 3 > Remove commas\n                getVisible(todoObj.list).map((item) =>\n                    `<li class=\"checklist-item ${statusToClass(item, 'done')}\">${item.descr}</li>`)\n                    .slice(0, 3).join('')\n            ) + (\n                (getVisible(todoObj.list).length > 3)\n                    ? '<div class=\"more-items-inside\"></div>' : ''\n            )\n            }</div>\n            <div class=\"button-container\">\n                <div class=\"done-toggle button\">Done</div>\n                <div class=\"delete button\">Delete</div>\n            </div>\n        </div>`;\n    return elementHTML;\n  },\n\n  /**\n   * Generate HTML for the element containing forms to create and append a new todo to the project\n   *\n   * {@link projectTemplates.add View}\n   * @memberof Views.Templates.ProjectTemplates\n   *\n   * @returns {string} Element's Outer HTML\n   */\n  add() {\n    const elementHTML =\n        `<form id=\"new-todo\" class=\"card\">\n            <input required class=\"title\" name=\"title\" placeholder=\"New Todo\">\n            <textarea class=\"descr\" name=\"descr\" placeholder=\"Description\"></textarea>\n            <h4 class=\"checklist-title\">Tasks</h4>\n            <div class=\"checklist-container\">\n                <input name =\"checklist\" class=\"checklist-input\">\n                <input name =\"checklist\" class=\"checklist-input\">\n                <input name =\"checklist\" class=\"checklist-input\">\n            </div>\n            <div class=\"button-container\">\n                <button type=\"submit\" id=\"add-todo\" class=\"button\">Add</button>\n                <button type=\"reset\" id=\"reset-todo-inputs\" class=\"button\">Reset</div>\n            </div>\n        </form>`;\n    return elementHTML;\n  },\n\n  /**\n   * Generate HTML for the element containing forms to create and append a new todo to the project\n   *\n   * {@link projectTemplates.edit View}\n   * @memberof Views.Templates.ProjectTemplates\n   *\n   * @param {Todo} todoObj Todo model object\n   * @returns {string} Element's Outer HTML\n   */\n  edit(todoObj) {\n    const activeList = getVisible(todoObj.list);\n    const elementHTML =\n        `<form class=\"edit-form card\">\n            <input required class=\"title\" name=\"title\" value=\"${todoObj.title}\">\n            <textarea class=\"descr\" name=\"descr\">${todoObj.descr}</textarea>\n            <h4 class=\"checklist-title\">Tasks</h4>\n            <div class=\"checklist-container\">\n                    <input name =\"list\" class=\"checklist-input\" value=\"${activeList[0] ? activeList[0].descr : \"\"}\">\n                    <input name =\"list\" class=\"checklist-input\" value=\"${activeList[1] ? activeList[1].descr : \"\"}\">\n                    <input name =\"list\" class=\"checklist-input\" value=\"${activeList[2] ? activeList[2].descr : \"\"}\">\n            </div>\n            <div class=\"button-container\">\n                <button type=\"submit\" id=\"add-todo\" class=\"button\">Save</button>\n                <div id=\"reset-todo-inputs\" class=\"button\">Delete</div>\n            </div>\n        </form>`;\n    return elementHTML;\n  },\n\n  /**\n   * Generate HTML for the element to add to the project view when there are no projects\n   *\n   * {@link projectTemplates.empty View}\n   * @memberof Views.Templates.ProjectTemplates\n   *\n   * @returns {string} Element's Outer HTML\n   */\n  empty() {\n    const elementHTML = '<div id=\"new-app\">← Add a new project</div>';\n    return elementHTML;\n  },\n\n};\n\nexport default projectTemplates;\n","import { statusToClass } from './helpers';\n\n/**\n* Each todo item has subtasks called checklist items which are stored in an array.\n* Rendering cheklist items is handled by a Populator-type View which iterates over\n* the parent Todo model's checklist array and generates separate elements for each checklist item.\n* <br><br>\n*\n* Checklist items can be created by the user through an 'Add Checklist Item' form element.\n*\n* {@link checklistTemplates Visit Module}\n* @namespace ChecklistTemplates\n* @memberof Views.Templates\n\n* @property {Function} standard - Create 'Standard Checklist Item' element HTML {@link checklistTemplates.standard see here}\n* @property {Function} add - Create 'Add Checklist Item' form element HTML {@link checklistTemplates.add see here}\n*/\nconst checklistTemplates = {\n\n  /** Checklist Item Model\n     * @typedef {import(\"../model.js\").ChecklistItem} ChecklistItem\n     */\n\n  /**\n     * Generate HTML for a form that lets users add checklsit items\n     *\n     * {@link checklistTemplates.add View}\n     * @memberof Views.Templates.ChecklistTemplates\n     *\n     * @returns {string} Element Outer HTML\n     */\n  add() {\n    const elementHTML = '<form id=\"new-checklist-item\"><input required placeholder=\"New task\" name=\"descr\"><form>';\n    return elementHTML;\n  },\n\n  /**\n   * Generate HTML for the standard view element that displays a checklist item\n   *\n   * {@link checklistTemplates.standard  View }\n   * @memberof Views.Templates.ChecklistTemplates\n   *\n   * @param {ChecklistItem} item Checklist item model object\n   * @returns {string} Element Outer HTML\n   */\n  standard(item) {\n    const elementHTML = `<div class=\"checklist-item ${statusToClass(item, 'done')}\" data-child-id=\"${item.id}\">\n                            <input class=\"descr\" value=\"${item.descr}\">\n                            <div class=\"item-button-container\">    \n                                <div class=\"item-button done-toggle\">✓</div>\n                                <div class=\"item-button delete\">x</div>\n                            </div>\n                        </div>`;\n    return elementHTML;\n  },\n};\n\nexport default checklistTemplates;\n","/**\n * Templates for the project list view, AKA the sidebar.\n *\n * The Project List uses a populator-type View which will iterate over its \n * projects array and generate elements for each project.\n *\n * There are also templates for adding new projects and editing existing projects. \n *\n * {@link projectListTemplates Visit Module}\n * @namespace ProjectListTemplates\n * @memberof Views.Templates\n *\n * @property {Function} standard - Create HTML for standard project element {@link projectListTemplates.standard see here}\n * @property {Function} add - Create HTML for a form element for adding a new project {@link projectListTemplates.add see here}\n * @property {Function} edit - Create HTML for form element for editing an existing project {@link projectListTemplates.edit see here}\n */\nconst projectListTemplates = {\n\n  /**\n   * Project model object\n   * @typedef {import('../model.js').Project} Project\n   */\n\n  /**\n   * Generate HTML for the standard element that displays a project's information and contains relevant buttons and attributes\n   *\n   * {@link projectListTemplates.standard View}\n   * @memberof Views.Templates.ProjectListTemplates\n   *\n   * @param {Project} project - Project model\n   * @returns {string} Element Outer HTML\n   */\n  standard(project) {\n    const elementHTML =\n        `<div class=\"project\"  data-child-id=\"${project.id}\" >\n        <p class=\"name\">${project.title}</p>\n        <div class=\"delete\">x</div>\n    </div>`;\n    return elementHTML;\n  },\n\n  /**\n   * Generate HTML for a form element for adding a new projects\n   * @memberof Views.Templates.ProjectListTemplates\n   * @returns {string} Element Outer HTML\n   */\n  add() {\n    const elementHTML =\n        '<form id=\"new-project\"><input required placeholder=\"New Project\" name=\"name\"><form>';\n    return elementHTML;\n  },\n\n  /**\n   * Generate HTML for a form element for editing an existing project\n   *\n   * {@link projectListTemplates.edit View}\n   * @memberof Views.Templates.ProjectListTemplates\n   *\n   * @param {Project} projectObj Project model to pull data from and fill the form\n   * @returns {string} Element Outer HTML\n   */\n  edit(projectObj) {\n    const elementHTML =\n        `<form class=\"edit-form\"><input required value=\"${projectObj.title}\" name=\"title\"><form>`;\n    return elementHTML;\n  },\n};\n\nexport default projectListTemplates\n","import templates from './templates';\n/**\n * Import model types\n * @typedef {import(\"./model\").DataModel}\n * @typedef {import(\"./model\").Todo}\n */\n\n/**\n * View classes used to draw different types of models to the DOM.\n * Also contains templates.\n * @namespace Views\n */\n\n/**\n * Consolidates generic containers for use by views.\n * <br><br>\n *\n * Built as a psuedo-dictionary using getters to select elements when called by a new view's constructor.\n * This circumvents containers that aren't in the DOM at page load (i.e. containers that are\n * elements in other yet-to-be-rendered views)\n *\n * {@link containers View}\n * @memberof Views~\n */\nconst containers = {\n  get Checklist() { return document.getElementById('checklist'); },\n  get Todo() { return document.body; },\n  get Project() { return document.querySelector('main'); },\n  get ProjectList() { return document.getElementById('projects'); },\n};\n\n/**\n * Parent abstract view class.\n *\n * Views handle drawing elements to the DOM based on data stored in a source model.\n * {@link View View}\n * @memberof Views~\n */\nclass View {\n  /**\n   * @param {DataModel} model Object to render data from\n   * @param {string} type View type i.e. Todo, Project, Project List\n   */\n  constructor(model, type) {\n    // Ensure class is abstract\n    if (this.constructor === View) throw new Error('Abstract Class');\n\n    /**\n     * View object's source data model\n     * @type {DataModel}\n     */\n    this.model = model;\n\n    /**\n     * DOM element to append view elements to\n     * @type {Element}\n     */\n    this.container = containers[type];\n\n    /**\n     * Generate a standard view element displaying a model object's data.\n     * @type {Function}\n     * @param {DataModel} model Model object\n     * @returns {Element} HTML element\n     */\n    this.standardTemplate = templates(type, 'standard');\n  }\n\n  /**\n   * Create standard element(s) and append to the container\n   * Some views might need to clear their container, or append extra elements.\n   */\n  render() { }\n}\n\n/**\n * This View class handles rendering and manipulating models that contain an\n * array of child models [Project List > Array of projects].\n * <br><br>\n *\n * The view handler loops through the array of child models to generate elements\n * and populates a specified DOM container with said elements.\n * <br><br>\n *\n * Each standard element can enter 'edit mode' if called by the controller, where\n * it's replaced by an edit form that allows the user to quickly change model properties.\n * <br><br>\n *\n * Populator views also have 'add' elements allowing the user to create a new child\n * model (logic is handled by the controller).\n * <br><br>\n *\n * {@link PopulatorView View}\n * @extends View\n * @extends Views~View\n * @memberof Views\n */\nclass PopulatorView extends View {\n  /**\n   * @param {DataModel} model Object to render data from\n   * @param {string} type View type i.e. Project, Project List\n   */\n  constructor(model, type) {\n    super(model, type);\n\n    /**\n     * List of child objects\n     * @type {DataModel[]}\n     */\n    this.list = model.list;\n\n    /**\n     * Generate Element for the user to add new child object\n     * @type {Function}\n     * @returns {Element}\n     */\n    this.addFormTemplate = templates(type, 'add');\n\n    /**\n     * Generate a form, initially filled with the object's data that allows the user to edit the object.\n     * @type {Function}\n     * @param {DataModel} model Model object\n     * @returns {Element} HTML element\n     */\n    this.editFormTemplate = templates(type, 'edit');\n  }\n\n  /**\n   * Filters removed (visible=false) objects from an array of model objects\n   * @param {DataModel[]} list Array of model objects\n   * @returns {DataModel[]} Filtered copy of original array\n   */\n  getActive() { return this.list.filter((model) => model.visible); }\n\n  /**\n   * Default rendering function that clears the view container and populates it with\n   * standard elements for each child object and a form to add new children.\n   *\n   * {@link render View}\n   */\n  render() {\n    this.container.innerHTML = ''; // Clear container\n\n    this.getActive().forEach((childObj) => {\n      const standardElement = this.standardTemplate(childObj);\n      this.container.appendChild(standardElement);\n    });\n\n    /**\n     * Reference to the DOM 'add child' form element\n     * @type {HTMLFormElement}\n     */\n    this.addForm = this.container.appendChild(this.addFormTemplate()); // Append 'Add \"model\"' element\n  }\n\n  /**\n   * Switch the DOM element representing the child model with an 'edit form' that's\n   * pre-filled with the model's original properties and allows the user to edit those properties.\n   *\n   * {@link editMode View}\n   *\n   * @param {number} id - ID of the child model object being edited\n   */\n  editMode(id) {\n    const elementToEdit = this.container.querySelector(`[data-child-id=\"${id}\"]`);\n\n    /**\n     * Reference to the DOM 'edit child' form element\n     * @type {HTMLFormElement}\n     */\n    this.editForm = this.editFormTemplate(this.model.list[id]);\n\n    elementToEdit.replaceWith(this.editForm);\n  }\n\n  /**\n   * Add or remove an HTML class to the element representing the child object.\n   * It's also possible to set the class to the specific child exclusively by\n   * removing it from all other children elements.\n   *\n   * {@link setClass View}\n   *\n   * @param {number} id - The ID of the child model object\n   * @param {string} className- The class to be added/removed\n   * @param {boolean} remove - True: Remove class. False: Add class. (Default: False)\n   * @param {boolean} exclusive - True: Remove class from all other children. (Default: False)\n   */\n  setClass(id, className, remove = false, exclusive = false) {\n    [...this.container.children].forEach((el) => {\n      const elementID = parseInt(el.getAttribute('data-child-id'), 10);\n      if (elementID === id) el.classList[(remove ? 'remove' : 'add')](className);\n      if (exclusive) el.classList.remove(className);\n    });\n  }\n}\n\n/**\n * Handles the rendering and DOM manipulation for a modal element that displays the details\n * for a specific Todo model. Can be generalized for other models that would benefit\n * from being rendered as a single modal.\n *\n * {@link TodoView View}\n *\n * @extends View\n * @extends Views~View\n * @memberof Views\n */\nclass TodoView extends View {\n  /**\n   * @param {Todo} todo  Source Todo model object\n   */\n  constructor(todo) {\n    super(todo, 'Todo');\n  }\n\n  render() {\n    // Generate and append element\n    this.standardElement = this.standardTemplate(this.model);\n    this.container.appendChild(this.standardElement);\n\n    /**\n     * The modal body is composed of a form that's pre-filled with the model data.\n     * The controller handles how to update the model using user inputs into its fields.\n     * @type {HTMLFormElement}\n     */\n    this.form = this.standardElement.querySelector('form');\n  }\n\n  /**\n   * Remove modal element from the container\n   */\n  hide() {\n    this.container.removeChild(this.standardElement);\n  }\n\n  /**\n   * Add or Remove an HTML class to the modal.\n   * @param {string} className - The class to be added to the modal's body\n   * @param {Boolean} remove - True: Remove class. False: Add class. (Default: False)\n   */\n  setClass(className, remove = false) {\n    this.form.classList[(remove ? 'remove' : 'add')](className);\n  }\n}\n\n/**\n * When there are no projects in the proejct list, this renders a default element\n * in the project container that normally holds Todo cards. This view is called by\n * the project list controller.\n *\n * {@link NewAppView View}\n * @memberof Views.\n */\nclass NewAppView {\n  constructor() {\n    this.emptyTemplate = templates('Project', 'empty');\n    this.container = containers.Project;\n    this.render();\n  }\n\n  render() {\n    this.container.innerHTML = '';\n    this.element = this.emptyTemplate();\n    this.container.appendChild(this.element);\n  }\n}\n\nexport {\n  PopulatorView,\n  TodoView,\n  NewAppView,\n};\n","import {\n  ChecklistItem,\n  Todo,\n  Project,\n  ProjectList,\n} from './model';\n\nimport {\n  PopulatorView,\n  TodoView,\n  NewAppView,\n} from './view';\n\n/** @typedef {import('./model').DataModel} DataModel */\n\n/**\n * Controllers handle manipulating models, creating and controlling views, and handling events.\n * @namespace Controllers\n */\n\n/**\n * Main app instance\n * @type {ProjectList}\n * @memberof Controllers\n */\nconst instance = new ProjectList();\n\n/**\n * Helper functions to facilitate some repetitive tasks:\n * @namespace Controllers.ControllerHelpers\n */\n\n/**\n * Selects certain elements in a specific parent element and adds listeners to each.\n * @memberof Controllers.ControllerHelpers\n * @param {Object} context - Controller instance to bind callbacks to since they're class methods\n * @param {HTMLElement} parent - DOM node to select from\n * @param {string} selector - Selector of elements to add listeners to\n * @param {string} event - Event type to listen for i.e. 'click'\n * @param {function(event)} callback - Function to run when event is triggered\n */\nfunction setListeners(context, parent, selector, event, callback) {\n  const elements = parent.querySelectorAll(selector);\n  if (!elements) return;\n\n  for (const el of elements) el.addEventListener(event, callback.bind(context));\n}\n\n/**\n * Gets model object's ID from event target's data attribute for callbacks that\n * take ID as input.\n * @memberof Controllers.ControllerHelpers\n * @param {Event} event - Event object with target HTML element data\n * @returns {number} - ID of model object linked to event target\n */\nfunction getID(event) {\n  const itemContainerEl = event.composedPath().find((el) => el.hasAttribute('data-child-id'));\n  return parseInt(itemContainerEl.getAttribute('data-child-id'), 10);\n}\n\n/**\n * Parent abstract class for Controllers which update the model and re-render view.\n * They also assigns event listeners to relevant view elements.\n * Subclasses are hierarchical like models & views: Project List > Project > .\n *\n * {@link Controller View}\n * @memberof Controllers~\n */\nclass Controller {\n  /**\n   * @param {DataModel} model Source model to be editied\n   */\n  constructor(model) {\n    // Ensure class is abstract\n    if (this.constructor === Controller) throw new Error('Abstract Class');\n    /**\n     * @type {DataModel}\n     */\n    this.model = model;\n  }\n\n  /** Save overall app model to local storage */\n  save() {\n    localStorage.projectList = JSON.stringify(instance.list);\n  }\n\n  /**\n   * Update procedure after model manipulations that affect view elements.\n   * 1. Save Project List instance in local storage\n   * 2. Re-render view elements\n   * 3. Set relevant event listeners\n   */\n  update() {\n    this.save();\n    this.view.render();\n    this.listeners();\n  }\n\n  // Abstract methods extepcted of each controller:\n\n  /** Edit model/child data */\n  edit() { }\n\n  /** Set event listeners to elements rendered by the view */\n  listeners() { }\n\n  /** Remove relevant model by setting visibility to false */\n  remove() { }\n\n  /** Toggle the 'done' status of the source/child model and update the relevant DOM element classes */\n  toggle() { }\n}\n\n/**\n * Parent controller for rendering and manipulating a list of child objects in parent models.\n * i.e. Rendering each Todo in an array of Todos in a parent Project model.\n *\n * {@link ListController View}\n * @memberof Controllers~\n * @extends Controller\n * @extends Controllers~Controller\n */\nclass ListController extends Controller {\n  /**\n   * @param {DataModel} parent Source parent model. Must contain an array called 'list' containing derived data model types\n   * @param {string} type Type of parent model, i.e 'ProjectList', 'Project', 'Todo'. Values according to the keys {@link Views~containers here}\n   */\n  constructor(parent, type) {\n    super(parent);\n    /**\n     * List of child objects\n     * @type {DataModel[]}\n     */\n    this.list = this.model.list;\n    /**\n     * A populator view created with the parent model\n     * @type {PopulatorView}\n     */\n    this.view = new PopulatorView(this.model, type);\n  }\n\n  /** Add child model */\n  add() { }\n\n  /**\n   * 'Deletes' child object by hiding it then runs update() above. View renderer\n   * ignores objects with visislbe = false. This design decision is explained\n   * at the Model class.\n   * @param {number} id - child objects id, AKA it's index\n   */\n  remove(id) {\n    this.list[id].visible = false;\n    this.update();\n  }\n\n  /**\n   * Toggle the status (done or not) of a model or child and add/remove a\n   * 'done' class to the relevant view element\n   * @param {number} id ID/index of the model/child to toggle\n   */\n  toggle(id) {\n    // Edit Model\n    this.list[id].status = !this.list[id].status;\n\n    // Add/remove class in view depending on new status.\n    const removeClass = !this.list[id].status; // Status: flase >> child isn't done >> Remove 'done' = true.\n\n    this.view.setClass(id, 'done', removeClass);\n  }\n\n  /**\n    * Filters list of child objects and only keep ones where visible = true.\n    * @returns {Array} - Array of child objects\n    */\n  getVisible() {\n    return this.list.filter((child) => child.visible);\n  }\n}\n\n/**\n * Controller for checklists, which are an array in each Todo containing checklist items.\n * The parent Todo which contains the list, is the source model since rendering and data manipulation\n * the whole list.\n *\n * {@link ChecklistController View}\n * @memberof Controllers\n * @extends ListController\n * @extends Controllers~ListController\n */\nclass ChecklistController extends ListController {\n  /**\n   * @param {Todo} todo Parent todo\n   */\n  constructor(todo) {\n    super(todo, 'Checklist');\n    super.update();\n  }\n\n  /**\n   * Edit a checklist item live by updating the model with each input\n   * @param {InputEvent} event User input in the field\n   */\n  edit(event) { // Pass Event as input to cleanly get and use event target's value\n    const itemID = getID(event); // Instead of using getID then edit(id) in the callback\n    const inputValue = event.target.value;\n    if (inputValue) { // If field isn't empty, update item's model\n      this.list[itemID].descr = inputValue;\n      super.save();\n    } else { // If field is empty, remove item, and update (save and re-render)\n      super.remove(itemID);\n      this.update();\n      this.view.addForm.descr.focus(); // Focus add form's input if user still wants to enter an item\n    }\n  }\n\n  /** Add a new checklist item to the model when the user makes an input in the add form */\n  add() {\n    const form = this.view.addForm;\n    const id = this.list.length;\n    this.list.push(new ChecklistItem(id, form.descr.value));\n    this.update();\n\n    // Focus newly created input and put cursos at the end by resetting the value (kinda hacky)\n    const checklistElement = this.view.container.querySelector(`[data-child-id=\"${id}\"] input`);\n    const tempDescr = checklistElement.value;\n    checklistElement.focus();\n    checklistElement.value = '';\n    checklistElement.value = tempDescr;\n  }\n\n  /** Set relevant listeners to each checklist item */\n  listeners() {\n    const { container } = this.view;\n    setListeners(this, container, '.checklist-item', 'input', this.edit);\n    setListeners(this, container, '#new-checklist-item', 'input', this.add);\n    setListeners(this, container, '.delete', 'click', (e) => this.remove(getID(e)));\n    setListeners(this, container, '.done-toggle', 'click', (e) => super.toggle(getID(e)));\n  }\n}\n\n/**\n * Controller for the detailed Todo View modal. Automatically renders modal when instanced\n *\n * {@link TodoController View}\n * @memberof Controllers\n * @extends Controller\n * @extends Controllers~Controller\n */\nclass TodoController extends Controller {\n  /**\n   * @param {classes['Todo']} todo Source Todo model\n   */\n  constructor(todo) {\n    super(todo);\n    /**\n     * @type {TodoView}\n     */\n    this.view = new TodoView(todo);\n\n    this.update(); // Render and set listeners\n\n    /**\n     * The modal body. An form element with fields for each model property, pre-filled with\n     * their original values. User inputs updated the model {@link edit see here}\n     * @type {HTMLFormElement}\n     */\n    this.form = this.view.form;\n\n    /**\n     * Checklist controller that handles rendering and updating the array of\n     * child checklist item objects\n     * @type {ChecklistController}\n     */\n    this.checklist = new ChecklistController(todo);\n  }\n\n  /** Hide the modal and re-render project view */\n  close() {\n    this.view.hide();\n    this.projectController.update();\n  }\n\n  /** Close modal if the user clicks outside by submitting it, hence running {@link close} */\n  clickOut(event) {\n    if (event.target === event.currentTarget) {\n      this.view.form.elements.save.click(); // submit() doesn't trigger listener\n    }\n  }\n\n  /** Edit the model live by updating it when a user makes in an input in field */\n  edit(event) {\n    const input = event.target;\n    const modelProperty = input.name; // Field names match model property names\n    this.model[modelProperty] = input.value;\n    this.save(); // Save to local storage\n  }\n\n  /** Set Todo's visibility to false and close the modal element (refreshing the project view) */\n  remove() {\n    this.model.visible = false;\n    this.close();\n  }\n\n  /** Toggle the status of the Todo element and toggle the 'done' class on the modal */\n  toggle() {\n    this.model.status = !this.model.status;\n\n    const removeClass = !this.model.status;\n    this.view.setClass('done', removeClass);\n  }\n\n  /** Set relevant listeners to modal elements, the form, and the background */\n  listeners() {\n    setListeners(this, this.view.form, 'input,textarea', 'input', this.edit);\n    setListeners(this, this.view.container, '#todo-background', 'click', this.clickOut);\n    setListeners(this, this.view.form, '.delete', 'click', this.remove);\n    setListeners(this, this.view.form, '.done-toggle', 'click', this.toggle);\n    this.view.form.addEventListener('submit', (e) => {\n      e.preventDefault();\n      this.close();\n    });\n  }\n}\n\n/**\n * Controller that manages Project models and views. Projects are essentially\n * parent containers of Todo elements, so the controller handles the array of todos.\n *\n * @extends ListController\n * @extends Controllers~ListController\n * @memberof Controllers\n */\nclass ProjectController extends ListController {\n  /**\n   * @param {Project} project Source projet model\n   */\n  constructor(project) {\n    super(project, 'Project');\n    super.update();\n  }\n\n  /** Add todo element to project based on form input values */\n  add(event) {\n    event.preventDefault();\n\n    const inputs = event.target.elements; // HTMLCollection: [title, desc, checklist1, checklist2, checklist3]\n    const inputValues = [...inputs].map((element) => element.value); // Convert to array of values\n    const [title, descr, ...checklist] = inputValues;\n\n    const list = checklist.filter((itemDescr) => itemDescr).map((itemDescr, i) => new ChecklistItem(i, itemDescr)); // id, descr\n\n    const [startDate, endDate] = [null, null];\n    const id = this.list.length;\n\n    const todo = new Todo(id, title, descr, startDate, endDate, list);\n    this.list.push(todo);\n\n    super.update();\n  }\n\n  /**\n   * Replace the Todo card with a form containing the original values.\n   * Submitting the form then updates the model with the new values and updates the\n   *  view/listeners and local storage\n   */\n  edit(id) {\n    super.update(); // Avoids multiple concurrent editing forms. Doesn't save changes.\n\n    this.view.editMode(id);\n    this.view.container.querySelector('.edit-form').addEventListener('submit', (event) => {\n      event.preventDefault();\n\n      const inputs = [...event.target.elements].filter((el) => (el.tagName !== 'BUTTON')); // Filter out buttons\n      const inputValues = inputs.map((el) => el.value);\n      const [newTitle, newDescr, ...newList] = inputValues;\n\n      const todoModel = this.model.list[id]; // Child Todo model instance being edited\n      todoModel.title = newTitle;\n      todoModel.descr = newDescr;\n\n      // Handle Checklist items by comparing the model's visible checklist items with the 3 inputs's values (newList)\n      const renderedList = todoModel.list.filter((item) => item.visible); // Get visible items\n      newList.forEach((itemDescr, i) => {\n        if (!itemDescr && !renderedList[i]) return; // Skip if field is empty and nothing was rendered\n\n        if (renderedList[i]) { // If an item was rendered:\n          const itemID = renderedList[i].id; // Get the actual index of the item in the model list\n\n          if (!itemDescr) {\n            todoModel.list[itemID].visible = false; // If the corresponding field is now empty, hide/remove the item\n          } else {\n            todoModel.list[itemID].descr = itemDescr; // Otherwise update its value\n          }\n        } else { // If there's no corresponding visible item, then add a new item to the model\n          const newID = todoModel.list.length;\n          todoModel.list.push(new ChecklistItem(newID, itemDescr));\n        }\n      });\n\n      super.update();\n    });\n  }\n\n  /** Select a Todo item and load it into a {@link TodoController} */\n  select(id) {\n    this.todoController = new TodoController(this.list[id]);\n\n    /**\n     * Parent project controller\n     * @type {ProjectController}\n     */\n    this.todoController.projectController = this; // Add parent controller property to call update() after closing the modal.\n  }\n\n  /** Set listeners for all Todo cards child elements in the project view container and the add form.  */\n  listeners() {\n    const { container } = this.view;\n    this.view.addForm.addEventListener('submit', this.add.bind(this));\n    setListeners(this, container, '.delete', 'click', (e) => this.remove(getID(e)));\n    setListeners(this, container, '.done-toggle', 'click', (e) => super.toggle(getID(e)));\n    setListeners(this, container, '.card:not(#new-todo) :is(p,h2,h4,li)', 'dblclick', (e) => this.edit(getID(e)));\n    setListeners(this, container, '.card:not(#new-todo, button)', 'click', (e) => {\n      if (e.target === e.currentTarget) { this.select(getID(e)); }\n    });\n  }\n}\n\n/** Handles the overall app model instance, which is an array of project models */\nclass ProjectListController extends ListController {\n  constructor() {\n    super(instance, 'ProjectList');\n    super.update();\n\n    // Get enabled projects and select the first one by default\n    this.selectDefault();\n  }\n\n  /** Add project when 'add form' is submitted */\n  add(event) {\n    event.preventDefault();\n\n    const id = this.list.length;\n    const title = event.target.elements.name.value;\n    this.model.list.push(new Project(id, title));\n\n    super.update();\n    this.select(id); // Switch to new project\n  }\n\n  /** Select a child project from the array given its ID by creating a project controller instance */\n  select(id) {\n    const project = this.model.list[id];\n    /**\n     * Controller for the currently loaded project.\n     * @type {ProjectController}\n     */\n    this.projectController = new ProjectController(project); // New controller instance updates/renders its view\n\n    /**\n     * @type {classes['Project']}\n     */\n    this.previousProject = this.activetProject; // Record last selected project incase active project is removed\n\n    /**\n     * @type {classes['Project']}\n     */\n    this.activetProject = project;\n\n    this.view.setClass(id, 'active', false, true); // Set relevant child view element to active\n  }\n\n  /**\n   * Default selection logic when loading the controller for the first time or when removing the current\n   * project and the previous proejct was already removed.\n   */\n  selectDefault() {\n    const visibleProjects = super.getVisible();\n\n    if (visibleProjects.length) {\n      this.select(visibleProjects[0].id);\n    } else {\n      this.emptyView = new NewAppView(); // Create a view in the Project View\n      // container asking the user to create a new porject\n    }\n  }\n\n  /**\n   * Remove a child project object. Since a project should always be selected,\n   * this handles the selection logic incase the active project is deleted.\n   */\n  remove(id) {\n    super.remove(id); // Remove project model from project list's array and update the sidebar.\n\n    // Rendering the sidebar doesn't show the selected project, so we reselect it.\n    // Also, we might have removed the currently selected project so we'd need\n    // to select a different one.\n    if (id === this.activetProject.id) { // If we removed the active project\n      if (this.previousProject?.visible) {  // Check if the previous project is visible\n        this.select(this.previousProject.id); // And select it (feels better than just selecting the first project)\n      } else { \n        this.selectDefault(); // Or select the first visible project if it isn't visible\n      }\n    } else {\n      this.select(this.activetProject.id); // Reselect the active project if it wasn't the one removed\n    }\n  }\n\n  /**\n   * Replace the project container with an pre-filled form that the user can edit.\n   * The model value is updated with each input to make editing feel more seamless.\n   */\n  edit(id) {\n    super.update(); // Avoids multiple concurrent editing forms. Doesn't save changes.\n\n    this.view.editMode(id); // Replace field with pre-filled edit form using the model\n\n    const titleInput = this.view.editForm.title;\n    titleInput.focus();\n\n    // Put cursor at the end\n    const tempvalue = titleInput.value;\n    titleInput.value = '';\n    titleInput.value = tempvalue;\n\n    const project = this.model.list[id];\n    const originalTitle = project.title; // Save original incase view updates while form's empty\n\n    titleInput.addEventListener('input', () => {\n      const newTitle = titleInput.value;\n      if (newTitle) { project.title = newTitle; } else { project.title = originalTitle; } // If field's empty, keep the original title in the model\n    });\n\n    /**\n     * Callback to run when the user finishes editing by sumbitting the form or defocusing the input field.\n     * @param {SubmitEvent|FocusEvent} event Event that fires when the user finishes editing.\n     */\n    const finishEdit = (event) => {\n      event.preventDefault(); // Incase it's a submit even\n      super.update(); // Only save to local storage after finishing\n      this.select(id); // Reselect the project being edited.\n    };\n\n    this.view.editForm.addEventListener('focusout', finishEdit);\n    this.view.editForm.addEventListener('submit', finishEdit);\n  }\n\n  /** Set event listeners to relevant child project elements and the 'add project' form */\n  listeners() {\n    const { container } = this.view;\n    this.view.addForm.addEventListener('submit', this.add.bind(this));\n    setListeners(this, container, '.name', 'click', (e) => this.select(getID(e)));\n    setListeners(this, container, '.delete', 'click', (e) => this.remove(getID(e)));\n    setListeners(this, container, '.project', 'dblclick', (e) => this.edit(getID(e)));\n  }\n}\n\nexport default ProjectListController;\n","import ProjectListController from './controller';\nimport './assets/style.css';\n\nconst App = new ProjectListController();\n"],"names":["DataModel","id","this","status","visible","ChecklistItem","descr","Todo","title","endDate","startDate","list","Project","ProjectList","storedData","localStorage","projectList","JSON","parse","statusToClass","model","htmlClass","getVisible","filter","item","convertElement","elementHTML","tempWrapper","document","createElement","innerHTML","childElementCount","firstChild","viewTemplates","standard","todoObj","map","slice","join","length","add","edit","activeList","empty","Checklist","project","projectObj","templates","view","type","templateHTML","containers","getElementById","body","querySelector","View","constructor","Error","container","standardTemplate","PopulatorView","addFormTemplate","editFormTemplate","getActive","forEach","childObj","standardElement","appendChild","addForm","elementToEdit","editForm","replaceWith","className","remove","exclusive","children","el","parseInt","getAttribute","classList","TodoView","todo","form","removeChild","NewAppView","emptyTemplate","render","element","instance","setListeners","context","parent","selector","event","callback","elements","querySelectorAll","addEventListener","bind","getID","itemContainerEl","composedPath","find","hasAttribute","Controller","stringify","save","listeners","ListController","update","removeClass","setClass","child","ChecklistController","itemID","inputValue","target","value","focus","push","checklistElement","tempDescr","e","TodoController","checklist","hide","projectController","currentTarget","click","input","modelProperty","name","close","clickOut","toggle","preventDefault","ProjectController","itemDescr","i","editMode","tagName","newTitle","newDescr","newList","todoModel","renderedList","newID","todoController","select","ProjectListController","selectDefault","previousProject","activetProject","visibleProjects","emptyView","titleInput","tempvalue","originalTitle","finishEdit"],"sourceRoot":""}